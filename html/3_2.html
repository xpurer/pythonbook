<!doctype html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" type="text/css" href="file/c.css" media="all"><title>数据库 与 ORM</title></head><body>
<a id="bar" href="index.html">返回目录</a>
<div id="header">
<h1>数据库 与 ORM</h1>
</div>

<div id="preamble">
<p>很多人在大学都学过数据库，喜欢用那些第一范式，第二范式 ... 第X范式，来指导表设计。</p>
<p>这些设计思想充满了数学上的优雅和形式上的美感，不过正如一位低调的前辈大牛所说的那样：</p>
<blockquote>
<p>学者要干的事情和街上混的程序员们干的事情完全不同，解决方案自然也完全两样。拿学术大师的话去指导产品开发，是要吃大亏的 ...</p>
</blockquote>
<p>好吧，先把那些范式忘了吧，欢迎回到现实世界。</p>
<p>数据库的设计，向来是根据应用场景而设计。下面我们假设应用场景为千万级访问量的Web2.0网站，数据库为MySQL。</p>
<p>MySQL是Web2.0网站用的最广泛的数据库了，它在Facebook，Baidu，Google都有使用。想要深入的了解MySQL，可以看看它的官方文档 <a href="page/other/learn_html_css.chm" target="_blank">链接</a> ，下面提一些注意点。</p>
<p>在设计表的时候，不要显式的声明数据库中的外键关系。数据库中使用外键关系会显著拖累数据库的性能，同时制约了数据库表的可拆分性。</p>
<p>需要作为where条件查询的字段，要加上索引。多个字段联合索引，比如 boy_id - grid_id , 当where条件中包含 boy_id 和 grid_id ，或只有 boy_id 时会使用该索引，当 where条件中只有 grid_id 时，不会使用该索引 。</p>
<p>可以用explian语句查看索引使用的细节，比如</p>
<div class="content"><pre>
explain select * from friends where grid_id = 987654;
</pre></div>
<p>如果字段的名字是sql语句的关键词 -- 比如 key ，你在查询时需要加上反引号，如下：</p>
<div class="content"><pre>
select * from misc where `key` = "salt";
</pre></div>
<p>每一张表中，不要有太多字段，但应该都有一个自增的id作为主键。</p>
<p>总而言之，只使用MySQL最简单最基本功能。更多细节现在就不扯了，以后碰到再慢慢说，我们开始实战。</p>
<p>首先创建数据库，第一个数据库的名词就取世界树的缩写（World Tree）叫做 wtree 吧。</p>
<div class="content"><pre>
CREATE DATABASE wtree CHARACTER SET utf8 COLLATE utf8_bin;
use wtree;
</pre></div>
<p>创建时指定编码为 utf8_bin ，这样以后建表的默认编码就是 utf8_bin 了。</p>
<p>首先设计四个表 -- 用户的电子邮件表，用户密码表，用户申请注册的表 和 用户的基本信息表。</p>
<p>建表可以使用一些辅助工具，比如客户端的MySQL GUI Tools （ <a target="_blank" href="http://dev.mysql.com/downloads/gui-tools/">http://dev.mysql.com/downloads/gui-tools/</a> ） ，或WEB界面的phpmyadmin( <a target="_blank" href="http://www.phpmyadmin.net/">http://www.phpmyadmin.net/</a> )。</p>
<p>用户电子邮件表结构很简单，只有2列。电子邮件表中的id就是用户的id。我们将其自增主键id的起始值设置为一千万，小于一千万的id预留做其他用途。</p>
<p>数值类型，比如 int ，后面圆括号是指出最大的显示尺寸，与实际的存储范围无关。</p>
<div class="content"><pre>
CREATE TABLE `user_email` (
  `id` int(10) unsigned NOT NULL auto_increment,
  `email` varchar(128) collate utf8_bin default NULL,
  PRIMARY KEY  (`id`),
  UNIQUE KEY `email` (`email`)
) ENGINE=MyISAM AUTO_INCREMENT=10000000 DEFAULT CHARSET=utf8 COLLATE=utf8_bin;
</pre></div>
<p>密码表，我们不存放密码原文，而存放用 sha256 哈希过的密码。binary表示是二进制数值。</p>
<div class="content"><pre>
CREATE TABLE `user_password` (
  `id` int(10) unsigned NOT NULL auto_increment,
  `password` binary(32) default NULL,
  PRIMARY KEY  (`id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8 COLLATE=utf8_bin;
</pre></div>
<p>用户申请注册的表如下，其中 ck 是 challenge key 的缩写，代表激活码。：</p>
<div class="content"><pre>
CREATE TABLE `user_apply` (
  `id` int(10) unsigned NOT NULL auto_increment,
  `ck` binary(6) NOT NULL,
  `time` timestamp NOT NULL default CURRENT_TIMESTAMP,
  `name` varchar(8) collate utf8_bin default NULL,
  PRIMARY KEY  (`id`),
  KEY `time` (`time`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8 COLLATE=utf8_bin;
</pre></div>
<p>用户表如下，url是让用户可以指定个性化的url，ver是用户头像的版本号，作用和之前介绍过的静态文件的版本号一样。</p>
<p>用户表的是存储引擎是Innodb。</p>
<p>MySQL有两大存储引擎，MyISAM和Innodb。</p>
<p>MyISAM 为读操作优化，速度比较快，但是写使用全局锁，并发性差，并且不支持事务。</p>
<p>InnoDB 是行级锁，写并发性能好，支持事务，但读取相比会慢一些。</p>
<p>注册以后，用户可以自行修改用户名，上传头像时会改动版本号，所以该表可能会有频繁的修改，因此选用 Innodb。</p>
<p>当然，对于小规模的网站，这些细微地性能差异可以忽略。</p>
<div class="content"><pre>
CREATE TABLE `user` (
  `id` int(10) unsigned NOT NULL auto_increment,
  `name` char(8) collate utf8_bin NOT NULL,
  `url` varchar(32) collate utf8_bin default NULL,
  `ver` tinyint(3) unsigned NOT NULL default '0',
  PRIMARY KEY  (`id`),
  UNIQUE KEY `url` (`url`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin;
</pre></div>
<p>在数据库中创建上述表之后，修改 myconf/config.py ，配置数据库。</p>
<div class="content"><pre>
WTREE_HOST = "localhost:3306:wtree:root:111111"

... ... ...

if not DATABASE_CONFIG:
    DATABASE_CONFIG = {
        "wtree": {
            "master": WTREE_HOST,
            "tables": (
                "*",
                "user","user_apply","user_password","user_email",
            ),
        },
    }
</pre></div>
<p>tables是指定表在哪一个数据库中，*是通配符，代表默认数据库。</p>
<p>这样，将来不同的表可以方便的分解到不同机器上的数据库中去，以便实现最简单的分布式。</p>
<p>同时去新浪申请一个邮箱,我们先借用新浪邮件的SMTP服务器来发邮件。申请完成后，同样修改一下配置。</p>
<div class="content"><pre>
#系统发信人的邮箱地址和显示名称
SYS_EMAIL_SENDER = "stdyun@sina.com"
SYS_EMAIL_SENDER_NAME = "stdyun"

#发信的SMTP服务器，用户名，密码
SMTP = "smtp.sina.com"
SMTP_USERNAME = "stdyun"
SMTP_PASSWORD = "xxxxxx"
</pre></div>
<p>编辑 mysite/model/user.py 。</p>
<div class="content"><pre>
#coding:utf-8
from init_db import McModel, Model
from mysite.util.security import get_ck
from base64 import urlsafe_b64encode
from sendmail import render_email
from struct import pack
from hashlib import sha256 as password_hash

class UserEmail(McModel):
    pass

class UserPassword(Model):
    def verify(self, password):
        p = self.password
        return p == hash_password(self.id, p)

class UserApply(Model):
    pass

class User(McModel):
    pass

def hash_password(id, password):
    return password_hash("%s%s"%(password, pack('L', id))).digest()

def send_apply_email(email, name, id, ck):
    render_email("auth/send_apply_email", email, name, id=id, ck=ck)

def apply(email, password, name):
    id = UserEmail.get_or_create(email=email).id

    password = hash_password(id, password)
    user_password = UserPassword.get(id=id)
    if user_password is None:
        user_password = UserPassword(id=id)
    user_password.password = password
    user_password.save()

    apply = UserApply.get(id)
    if apply is None:
        apply = UserApply(id=id, ck=get_ck())
    apply.name = name
    apply.save()

    ck = urlsafe_b64encode(apply.ck)

    send_apply_email(email, name, id, ck)

    return apply

def is_existed(email):
    e = UserEmail.get(email=email)
    if e:
        return User.mc_get(e.id)

def create_user(id):
    apply = UserApply.get(id)
    if apply:
        user = User(id=id, name=apply.name)
        user.save()
        apply.delete()
        return user

USER_RELATED_BY_ID = (User, UserEmail, UserApply, )

def remove_user_by_email(email):
    UserEmail.begin()
    e = UserEmail.get(email=email)
    if e:
        id = e.id
        for cls in USER_RELATED_BY_ID:
            cls(id=id).delete()
        e.delete()
    UserEmail.commit()
</pre></div>
<p>首先可以看到引入了 Model 和 McModel 。</p>
<p>Model 和 McModel 是一种 ORM 的基类。</p>
<p>ORM，全称 Object Relation Mapping ， 中文含义是对象和关系的映射。通过ORM，可以简化常见的增删查改，提高开发效率。</p>
<p>继承这个ORM的基类，它会自动的将数据库中表和对象进行映射。</p>
<p>McModel 和 Model 的区别是，McModel附带了Memcache的支持。</p>
<p>Memcache是一个高性能的基于内存的键值缓存，性能优异，是MySQL的十多倍，使用它可以提高页面的响应速度。</p>
<p>但更重要的是，简单的键值方式存储可以非常方便方便的实现多机分布式（Facebook用了600台memcached）。这样可以大大降低MySQL的查询压力 -- 通常，MySQL数据库是网站最瓶颈的地方。</p>
<p>我们将在以后的实战中慢慢介绍它。想要更深入的了解memcache可以看看这个手册 <a href="page/memcached.pdf" target="_blank">链接</a> 。</p>
<p>windows下，我们只做开发，所以不用启动memcache和修改配置文件，mypy框架会默认使用一个假的（fake）memcache。</p>
<p>接着看代码。</p>
<p>UserPassword中定义了verify方法，用来校验密码是否正确。</p>
<p>hash_password， 是用来对密码进行哈希的单向函数。数据库中是不保存密码明文的，即使数据库被黑客窃取，黑客也无法获知用户的密码。</p>
<p>不少黑客预先将大量常见密码的哈希值计算出来，试图通过查表的方式迅速破解密码。为了防止这种暴力破解，我们把密码与id拼接起来再做哈希。密码学上将这种用于拼接的字符串称为salt，中文含义为盐。</p>
<p>apply，就是用于创建申请的表了。其中用ORM来操作数据库，用到了ORM中的几个函数。</p>
<p>get_or_create，顾名思义，就是获取或创建，如果用SQL来写，类似于下面的代码。</p>
<div class="content"><pre>
cursor.execute("select * from user where email = %s limit 1", email)
result = cursor.fetchone()
if result is None:
    cursor.execute("insert into user (email) values (%s)",email)
</pre></div>
<p>get,获取单条记录。默认查询条件是id，比如</p>
<div class="content"><pre>
UserApply.get(e.id)
</pre></div>
<p>要指定查询,可以用类似下面的写法</p>
<div class="content"><pre>
UserApply.get(email=email)
</pre></div>
<p>新建的行，在ORM,可以在初始化时传入参数赋值；也可以在对象创建后，通过类操作赋值，最后记得要保存。如</p>
<div class="content"><pre>
apply = UserApply(id=id, ck=get_ck())
apply.name = name
apply.save()
</pre></div>
<p>接着往下看代码。</p>
<div class="content"><pre>
def is_existed(email):
    e = UserEmail.get(email=email)
    if e:
        return User.mc_get(e.id)
</pre></div>
<p>is_existed，用到了McModel中的一个函数，mc_get。</p>
<p>mc_get的参数是函数的id，它会先尝试从memcache中获取数据。</p>
<p>如果memcache中不存在该行，它会去数据库中查询。查询有结果，将缓存结果 -- 下一次mc_get就会从memcache中获取数据了。</p>
<p>对于那些可能会频繁读取的数据，我们使用memcache来缓存它，比如这里的user对象。</p>
<p>我们没有使用多表级联来查询结果。</p>
<p>多表级联会限制关联到的表必须在同一台服务器上，不利于以后的扩展。</p>
<p>正如 Dan Pritchard 在谈论eBay构架时那段对白</p>
<blockquote>
<p>对其它大型系统的架构，你有什么建议吗？</p>
<p>Dan Pritchard:</p>
<p>最简单的建议就是，给一个为小规模应用而设计的架构增加资源并不能让它变成大规模的架构。你必须打破常规模式，比如ACID和分布式事务。乐于寻找机会放松一些约束，即使传统上认为是不能放松的。</p>
<p>还有两条简单的原则：把每样东西都设计成分离的；考虑BASE、而不是ACID。</p>
</blockquote>
<p>是的，把每样东西都设计成分离的，这是一个好习惯。</p>
<p>最后看 remove_user_by_email ，这里的用于删除用户账号的。通常的删除方式是</p>
<div class="content"><pre>
cls.where(id=id).delete()
</pre></div>
<p>但这样做的缺点是需要手工的清空memcache，如果是根据id删除，可以采用下面这种写法，它能自动清空memcache。</p>
<div class="content"><pre>
cls(id=id).delete()
</pre></div>
<p>UserEmail.begin 是对 UserEmail 所在的数据库使用事务，它对这个数据库的所有InnoDB表都会造成影响。</p>
<p>不过启用事务并不是为了保证数据的完整性，而是可以减少InnoDB的自动提交（AUTOCOMMIT）。对于大量的修改操作而言，如果每次改变数据都自动提交，会导致性能急剧下降。</p>
<p>当然，对remove_user_by_email这个函数而言，用不用事务区别不大。</p>

<div class="dirnav">
<a href="3_1.html">上一节</a>
<a href="index.html">返回目录</a>
</div>

</div>

<script type="text/javascript" src="file/c.js"></script>
<div id="footer">
  <p class="copyright">
    Copyright 2009,
    张沈鹏,
	董诣,
    陈寅,
	<span class="amp">&amp;</span>
    敬宓    
  </p>
</div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-10347470-1");
pageTracker._trackPageview();
} catch(err) {}</script>
</body>





