数据库 与 ORM

很多人在大学都学过数据库，喜欢用那些第一范式，第二范式 ... 第X范式，来指导表设计。

这些设计思想充满了形式上的优雅和数学上的美感，不过正如一位低调的前辈大牛所说的那样：

“
学者要干的事情和街上混的程序员们干的事情完全不同，解决方案自然也完全两样。拿学术大师的话去指导产品开发，是要吃大亏的 ...
”

好吧，先把那些范式忘了吧，欢迎回到现实世界。

数据库的设计，向来是根据应用场景而设计。下面我们假设应用场景为千万级访问量的Web2.0网站，数据库为MySQL。

MySQL是Web2.0网站用的最广泛的数据库了，它在Facebook，Baidu，Google都有使用。想要深入的了解MySQL，可以看看它的官方文档 page:other/learn_html_css.chm ，下面提一些注意点。

首先，仔细选择MySQL使用的数据库引擎。MySQL有两大存储引擎，MyISAM和Innodb。

MyISAM 为读操作优化，速度比较快，但写是全局锁，并发性差，并且不支持事务。

InnoDB 是行级锁，写并发性能好，支持事务，但读取比较慢。

在设计表的时候，不要显式的声明数据库中的外键关系。数据库中使用外键关系会显著拖累数据库的性能，同时制约了数据库表的可拆分性。

需要作为where条件查询的字段，要加上索引。多个字段联合索引，比如 boy_id - grid_id , 当where条件中包含 boy_id 和 grid_id ，或只有 boy_id 时会使用该索引，当 where条件中只有 grid_id 时，不会使用该索引 。

可以用explian语句查看索引使用的细节，比如

{{{
explain select * from friends where grid_id = 987654;
}}}

如果字段的名字是sql语句的关键词 -- 比如 key ，你在查询时需要加上反引号，如下：
{{{
select * from misc where `key` = "salt";
}}}

每一张表中，不要有太多字段，但应该都有一个自增的id作为主键。

总而言之，只使用MySQL最简单最基本功能。更多细节现在就不扯了，以后碰到再慢慢说，还是先看看怎么设计用户表。

首先创建数据库，第一个数据库的名词就取世界树的缩写（World Tree）叫做 wtree 吧。

{{{
CREATE DATABASE wtree CHARACTER SET utf8 COLLATE utf8_bin;
use wtree;
}}}

创建时指定编码为 utf8_bin ，这样以后建表的默认编码就是 utf8_bin 了。

首先设计三个表 -- 用户的电子邮件表，用户密码表 和 用户申请注册的表 。

用户电子邮件表结构很简单，都只有2列，。

{{{
CREATE TABLE `user_email` (
  `id` int(10) unsigned NOT NULL auto_increment,
  `email` varchar(128) collate utf8_bin default NULL,
  PRIMARY KEY  (`id`),
  UNIQUE KEY `email` (`email`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8 COLLATE=utf8_bin;

CREATE TABLE `user_password` (
  `id` int(10) unsigned NOT NULL auto_increment,
  `password` binary(32) default NULL,
  PRIMARY KEY  (`id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8 COLLATE=utf8_bin;
}}}

对于密码，我们不存放原文，而存放用 sha256 哈希过的密码。binary表示是二进制数值。

用户申请注册的表如下：
{{{
CREATE TABLE `user_apply` (
  `id` int(10) unsigned NOT NULL auto_increment,
  `ck` binary(6) NOT NULL,
  `time` timestamp NOT NULL default CURRENT_TIMESTAMP,
  `name` varchar(8) collate utf8_bin default NULL,
  PRIMARY KEY  (`id`),
  KEY `time` (`time`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8 COLLATE=utf8_bin;
}}}

其中 ck 是 challenge key 的缩写，代表激活码。

























utf-8 编码的表中每一个定长char需要预备3个字节 ，因为这是可能的最大长度。因为我们生成ck只是英文和数字，为了节省空间，重定义了ck的编码集。

对于数值类型，比如 tinyint ，后面圆括号是指出最大的显示尺寸，与实际的存储范围无关。

接下来设计用户名表，用户的字段有 Email帐号，昵称，头像的版本号，个性url的后缀，性别，出身年代，是否单身，行业，职业，现居城市，家乡。

根据字段使用频率不同，我们用两个表来区别保存。

user表
{{{
CREATE TABLE `user` (
`id` INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY ,
`email` VARCHAR( 128 ) NOT NULL ,
`name` CHAR( 8 ) NOT NULL ,
`url` VARCHAR( 32 ) NULL ,
`ver` TINYINT UNSIGNED NOT NULL  DEFAULT 0,
UNIQUE email (`email`),
UNIQUE url(`url`)
) ENGINE = MYISAM CHARACTER SET utf8 COLLATE utf8_bin ;
}}}

user_profile表
{{{
CREATE TABLE `user_profile` (
 `id` int(10) unsigned NOT NULL auto_increment,
 `sex` char(1) character set ascii collate ascii_bin NOT NULL,
 `birth_age` tinyint(3) unsigned NOT NULL,
 `is_single` tinyint(4) NOT NULL,
 `industry` tinyint(3) unsigned NOT NULL,
 `title` varchar(16) collate utf8_bin NOT NULL,
 `city` smallint(5) unsigned NOT NULL,
 `hometown` smallint(5) unsigned NOT NULL,
 PRIMARY KEY  (`id`),
 KEY `industry` (`industry`),
 KEY `city_hometown` (`city`,`hometown`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin;
}}}

首先修改 myconf/config.py ，配置数据库。

{{{
WTREE_HOST = "localhost:3306:wtree:root:111111"

DATABASE_CONFIG = {
    "wtree": {
        "master": WTREE_HOST,
        "tables": ["*","user","user_profile","user_apply"],
    },
}
}}}

tables是指定表在哪一个数据库中，*是通配符，代表默认数据库。

这样，将来不同的表可以方便的分解到不同机器上的数据库中去，以便实现最简单的分布式。

编辑 mysite/model/user.py 。

{{{
#coding:utf-8
from init_db import McModel,Model

class UserApply(McModel):
    pass

class UserProfile(McModel):
    pass

class User(McModel):
    pass
}}}
























数据库表保持精简，对大文本字段单独建表存储。

这样做有两个好处，

其一，方便配合ORM和Memcache使用，能加快表的读取速度；

其二，将来大文本字段的存储，可以方便切换到分布式的键值数据库。

ORM，是 对象-表 的映射，用它可以简化常见的增删查找代码的编写，提高开发效率。

Memcache，是一个高性能的基于内存的键值缓存，性能优异，使用它可以提高页面的响应速度，同时降低mysql的查询压力。想要更深入的了解memcache可以看看这个手册 page:memcached.pdf 。



多对多 不要级联 数据表 索引表 
理念 把预先能计算的数据先准备好
可以容忍 必要的数据冗余




表小 数据切片



提示：使用UTF8时为了节省空间，使用VARCHAR而不要用CHAR。否则，MySQL必须为一个CHAR(10) CHARACTER SET utf8列预备30个字节，因为这是可能的最大长度。

column1 VARCHAR(5) CHARACTER SET latin1 COLLATE latin1_german1_ci


用户表 用户身份 管理员 企业 个人








    * 确保表表示单个主题:                 类似面向对象的单职责原则，一个对象一个职责。
    * 确保每个表都有一个主键：         主键唯一的标识了表中的每条记录；它还用来建立表之间的关系。
    * 确保字段只包含一个单独的值：   一个字段只表示一个内容。
    * 确保表中没有需要计算的字段
    (减少计算 容忍冗余)
    
现在，一个结构良好的表算是设计好了，现在我们可以把单个Employee和任意多个Committee关联起来，也可以把单个Committee和任意多个Employee关联起来。而且，可以使用一条SQL语句来同时查看来自所有这3个表的信息。
