数据库 与 ORM

很多人在大学都学过数据库，喜欢用那些第一范式，第二范式 ... 第X范式，来指导表设计。

这些设计思想充满了数学上的优雅和形式上的美感，不过正如一位低调的前辈大牛所说的那样：

==>
学者要干的事情和街上混的程序员们干的事情完全不同，解决方案自然也完全两样。拿学术大师的话去指导产品开发，是要吃大亏的 ...
<==

好吧，先把那些范式忘了吧，欢迎回到现实世界。

数据库的设计，向来是根据应用场景而设计。下面我们假设应用场景为千万级访问量的Web2.0网站，数据库为MySQL。

MySQL是Web2.0网站用的最广泛的数据库了，它在Facebook，Baidu，Google都有使用。想要深入的了解MySQL，可以看看它的官方文档 page:other/learn_html_css.chm ，下面提一些注意点。

在设计表的时候，不要显式的声明数据库中的外键关系。数据库中使用外键关系会显著拖累数据库的性能，同时制约了数据库表的可拆分性。

需要作为where条件查询的字段，要加上索引。多个字段联合索引，比如 boy_id - grid_id , 当where条件中包含 boy_id 和 grid_id ，或只有 boy_id 时会使用该索引，当 where条件中只有 grid_id 时，不会使用该索引 。

可以用explian语句查看索引使用的细节，比如

{{{
explain select * from friends where grid_id = 987654;
}}}

如果字段的名字是sql语句的关键词 -- 比如 key ，你在查询时需要加上反引号，如下：
{{{
select * from misc where `key` = "salt";
}}}

每一张表中，不要有太多字段，但应该都有一个自增的id作为主键。

总而言之，只使用MySQL最简单最基本功能。更多细节现在就不扯了，以后碰到再慢慢说，我们开始实战。

首先创建数据库，第一个数据库的名词就取世界树的缩写（World Tree）叫做 wtree 吧。

{{{
CREATE DATABASE wtree CHARACTER SET utf8 COLLATE utf8_bin;
use wtree;
}}}

创建时指定编码为 utf8_bin ，这样以后建表的默认编码就是 utf8_bin 了。

首先设计四个表 -- 用户的电子邮件表，用户密码表，用户申请注册的表 和 用户的基本信息表。

建表可以使用一些辅助工具，比如客户端的MySQL GUI Tools （ http://dev.mysql.com/downloads/gui-tools/ ） ，或WEB界面的phpmyadmin( http://www.phpmyadmin.net/ )。

用户电子邮件表结构很简单，只有2列。电子邮件表中的id就是用户的id。我们将其自增主键id的起始值设置为一千万，小于一千万的id预留做其他用途。
数值类型，比如 int ，后面圆括号是指出最大的显示尺寸，与实际的存储范围无关。
{{{
CREATE TABLE `user_email` (
  `id` int(10) unsigned NOT NULL auto_increment,
  `email` varchar(128) collate utf8_bin default NULL,
  PRIMARY KEY  (`id`),
  UNIQUE KEY `email` (`email`)
) ENGINE=MyISAM AUTO_INCREMENT=10000000 DEFAULT CHARSET=utf8 COLLATE=utf8_bin;
}}}



密码表，我们不存放密码原文，而存放用 sha256 哈希过的密码。binary表示是二进制数值。
{{{
CREATE TABLE `user_password` (
  `id` int(10) unsigned NOT NULL auto_increment,
  `password` binary(32) default NULL,
  PRIMARY KEY  (`id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8 COLLATE=utf8_bin;
}}}

用户申请注册的表如下，其中 ck 是 challenge key 的缩写，代表激活码。：
{{{
CREATE TABLE `user_apply` (
  `id` int(10) unsigned NOT NULL auto_increment,
  `ck` binary(6) NOT NULL,
  `time` timestamp NOT NULL default CURRENT_TIMESTAMP,
  `name` varchar(8) collate utf8_bin default NULL,
  PRIMARY KEY  (`id`),
  KEY `time` (`time`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8 COLLATE=utf8_bin;
}}}

用户表如下，url是让用户可以指定个性化的url，ver是用户头像的版本号，作用和之前介绍过的静态文件的版本号一样。

用户表的是存储引擎是Innodb。

MySQL有两大存储引擎，MyISAM和Innodb。

MyISAM 为读操作优化，速度比较快，但是写使用全局锁，并发性差，并且不支持事务。

InnoDB 是行级锁，写并发性能好，支持事务，但读取相比会慢一些。

注册以后，用户可以自行修改用户名，上传头像时会改动版本号，所以该表可能会有频繁的修改，因此选用 Innodb。

当然，对于小规模的网站，这些细微地性能差异可以忽略。

{{{
CREATE TABLE `user` (
  `id` int(10) unsigned NOT NULL auto_increment,
  `name` char(8) collate utf8_bin NOT NULL,
  `url` varchar(32) collate utf8_bin default NULL,
  `ver` tinyint(3) unsigned NOT NULL default '0',
  PRIMARY KEY  (`id`),
  UNIQUE KEY `url` (`url`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin;
}}}


在数据库中创建上述表之后，修改 myconf/config.py ，配置数据库。

{{{
WTREE_HOST = "localhost:3306:wtree:root:111111"

... ... ...

if not DATABASE_CONFIG:
    DATABASE_CONFIG = {
        "wtree": {
            "master": WTREE_HOST,
            "tables": (
                "*",
                "user","user_apply","user_password","user_email",
            ),
        },
    }
}}}

tables是指定表在哪一个数据库中，*是通配符，代表默认数据库。

这样，将来不同的表可以方便的分解到不同机器上的数据库中去，以便实现最简单的分布式。

同时去新浪申请一个邮箱,我们先借用新浪邮件的SMTP服务器来发邮件。申请完成后，同样修改一下配置。

{{{
#系统发信人的邮箱地址和显示名称
SYS_EMAIL_SENDER = "stdyun@sina.com"
SYS_EMAIL_SENDER_NAME = "stdyun"

#发信的SMTP服务器，用户名，密码
SMTP = "smtp.sina.com"
SMTP_USERNAME = "stdyun"
SMTP_PASSWORD = "xxxxxx"
}}}

编辑 mysite/model/user.py 。
{{{
#coding:utf-8
from init_db import McModel, Model
from mysite.util.security import get_ck
from base64 import urlsafe_b64encode
from sendmail import render_email
from struct import pack
from hashlib import sha256 as password_hash

class UserEmail(McModel):
    pass

class UserPassword(Model):
    pass

class UserApply(Model):
    pass

class User(McModel):
    pass

def hash_password(id, password):
    return password_hash("%s%s"%(password, pack('L', id))).digest()

def send_apply_email(email, name, id, ck):
    render_email("auth/send_apply_email", email, name, id=id, ck=ck)

def apply(email, password, name):
    id = UserEmail.get_or_create(email=email).id

    password = hash_password(id, password)
    user_password = UserPassword.get(id=id)
    if user_password is None:
        user_password = UserPassword(id=id)
    user_password.password = password
    user_password.save()

    apply = UserApply.get(id)
    if apply is None:
        apply = UserApply(id=id, ck=get_ck())
    apply.name = name
    apply.save()

    send_apply_email(email, name, id, apply.ck)

    return apply

def is_existed(email):
    e = UserEmail.get(email=email)
    if e:
        return User.mc_get(e.id)

def create_user(id):
    apply = UserApply.get(id)
    if apply:
        user = User(name=apply.name)
        user.save()
        apply.delete()
        return user
}}}

首先可以看到引入了 Model 和 McModel 。

Model 和 McModel 是一种 ORM 的基类。

ORM，全称 Object Relation Mapping ， 中文含义是对象和关系的映射。通过ORM，可以简化常见的增删查改，提高开发效率。

继承这个ORM的基类，它会自动的将数据库中表和对象进行映射。

McModel 和 Model 的区别是，McModel附带了Memcache的支持。

Memcache是一个高性能的基于内存的键值缓存，性能优异，是MySQL的十多倍，使用它可以提高页面的响应速度。

但更重要的是，简单的键值方式存储可以非常方便方便的实现多机分布式（Facebook用了600台memcached）。这样可以大大降低MySQL的查询压力 -- 通常，MySQL数据库是网站最瓶颈的地方。

我们将在以后的实战中慢慢介绍它。想要更深入的了解memcache可以看看这个手册 page:memcached.pdf 。

windows下，我们只做开发，所以不用启动memcache和修改配置文件，mypy框架会默认使用一个假的（fake）memcache。

接着看代码。

hash_password， 是用来对密码进行哈希的单向函数。数据库中是不保存密码明文的，即使数据库被黑客窃取，黑客也无法获知用户的密码。

不少黑客预先将大量常见密码的哈希值计算出来，试图通过查表的方式迅速破解密码。为了防止这种暴力破解，我们把密码与id拼接起来再做哈希。密码学上将这种用于拼接的字符串称为salt，中文含义为盐。

apply，就是用于创建申请的表了。其中用ORM来操作数据库，用到了ORM中的几个函数。

get_or_create，顾名思义，就是获取或创建，如果用SQL来写，类似于下面的代码。

{{{
cursor.execute("select * from user where email = %s limit 1", email)
result = cursor.fetchone()
if result is None:
    cursor.execute("insert into user (email) values (%s)",email)
}}}


get,获取单条记录。默认查询条件是id，比如
{{{
UserApply.get(e.id)
}}}

如果要指定查询,可以用类似下面的写法
{{{
UserApply.get(email=email)
}}}

新建的行，在ORM,可以在初始化时传入参数赋值；也可以在对象创建后，通过类操作赋值，最后记得要保存。如
{{{
apply = UserApply(id=id, ck=get_ck())
apply.name = name
apply.save()
}}}

接着，我们看下一个函数，is_existed。他用的McModel中的一个函数，mc_get。

mc_get的参数是函数的id，它会先尝试从memcache中获取数据。

如果memcache中不存在该行，它会去数据库中查询，如果查询有结果，将缓存结果 -- 下一次mc_get就会从memcache中获取数据了。

可以看到，这里我们没有使用多表级联来查询结果。用多表级联限制了这些表必须在同一台服务器上，不利于以后的扩展。

正如Dan Pritchard在谈论eBay构架时那段对白

==>
对其它大型系统的架构，你有什么建议吗？

Dan Pritchard:

最简单的建议就是，给一个为小规模应用而设计的架构增加资源并不能让它变成大规模的架构。你必须打破常规模式，比如ACID和分布式事务。乐于寻找机会放松一些约束，即使传统上认为是不能放松的。

还有两条简单的原则：把每样东西都设计成分离的；考虑BASE、而不是ACID。
<==

是的，把每样东西都设计成分离的。

最后再来看一眼
send_apply_email













utf-8编码的表中每一个定长char需要预备3个字节 ，因为这是可能的最大长度。如果只是英文和数字，可以重定义某一个字段的编码集，来节省空间。

数据库表保持精简，对大文本字段单独建表存储。

这样做有两个好处，

其一，方便配合ORM和Memcache使用，能加快表的读取速度；

其二，将来大文本字段的存储，可以方便切换到分布式的键值数据库。

ORM，是 对象-表 的映射，用它可以简化常见的增删查找代码的编写，提高开发效率。

Memcache，是一个高性能的基于内存的键值缓存，性能优异，使用它可以提高页面的响应速度，同时降低mysql的查询压力。想要更深入的了解memcache可以看看这个手册 page:memcached.pdf 。



多对多 不要级联 数据表 索引表 
理念 把预先能计算的数据先准备好
可以容忍 必要的数据冗余




表小 数据切片


