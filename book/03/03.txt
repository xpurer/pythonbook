数据库 与 ORM

很多人在大学都学过数据库，喜欢用那些第一范式，第二范式 ... 第X范式，来指导表设计。

这些设计思想充满了形式上的优雅和数学上的美感，不过正如一位低调的前辈大牛所说的那样：

“
学者要干的事情和街上混的程序员们干的事情完全不同，解决方案自然也完全两样。拿学术大师的话去指导产品开发，是要吃大亏的 ...
”

好吧，先把那些范式忘了吧，欢迎回到现实世界。

数据库的设计，向来是根据应用场景而设计。下面我们假设应用场景为千万级访问量的Web2.0网站，数据库为MySQL。

MySQL是Web2.0网站用的最广泛的数据库了，它在Facebook，Baidu，Google都有使用。

很有必要先通读一遍MySQL官方文档 page:other/learn_html_css.chm ，下面只提一些注意点。

首先，仔细选择MySQL使用的数据库引擎。MySQL有两大存储引擎，MyISAM和Innodb。

MyISAM 为读操作优化，速度比较快，但写是全局锁，并发性差，并且不支持事务。

InnoDB 是行级锁，写并发性能好，支持事务，但读取比较慢。

在设计表的时候，不要使用数据库中的外键。数据库中使用外键关系会显著拖累数据库的性能，同时制约了数据库表的可拆分性。

需要作为where条件查询的字段，要加上索引。多个字段联合索引，比如 boy_id - grid_id , 当where条件中包含 boy_id 和 grid_id ，或只有 boy_id 时会使用该索引，当 where条件中只有 grid_id 时，不会使用该索引 。

可以用explian语句查看索引使用的细节，比如

{{{
explain select * from friends where grid_id = 987654;
}}}

如果字段的名字是sql语句的关键词 -- 比如 key ，你在查询时需要加上反引号，如下：
{{{
select * from misc where `key` = "salt";
}}}

每一张表中，不要有太多字段，但应该都有一个自增的id。

数据库表保持精简，对大文本字段单独建表存储。

这样做有两个好处，

其一，方便配合ORM和Memcache使用，能加快表的读取速度；

其二，将来大文本字段的存储，可以方便切换到分布式的键值数据库。

ORM，是 对象-表 的映射。

page:memcached.pdf


Memcache


user_apply





多对多 不要级联 数据表 索引表 
理念 把预先能计算的数据先准备好
可以容忍 必要的数据冗余



CREATE DATABASE wtree CHARACTER SET utf8 COLLATE utf8_bin;

表小 数据切片



提示：使用UTF8时为了节省空间，使用VARCHAR而不要用CHAR。否则，MySQL必须为一个CHAR(10) CHARACTER SET utf8列预备30个字节，因为这是可能的最大长度。

column1 VARCHAR(5) CHARACTER SET latin1 COLLATE latin1_german1_ci


用户表 用户身份 管理员 企业 个人








    * 确保表表示单个主题:                 类似面向对象的单职责原则，一个对象一个职责。
    * 确保每个表都有一个主键：         主键唯一的标识了表中的每条记录；它还用来建立表之间的关系。
    * 确保字段只包含一个单独的值：   一个字段只表示一个内容。
    * 确保表中没有需要计算的字段
    (减少计算 容忍冗余)
    
现在，一个结构良好的表算是设计好了，现在我们可以把单个Employee和任意多个Committee关联起来，也可以把单个Committee和任意多个Employee关联起来。而且，可以使用一条SQL语句来同时查看来自所有这3个表的信息。
